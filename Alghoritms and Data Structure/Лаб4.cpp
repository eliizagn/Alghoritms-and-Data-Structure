/*
???????? ?? ??? ???? ????????, ?????????? ???????? ???? ? ???? ??? ????? ?????. ??????? ?????, ??????????? ?????? 
?????????? ?? ??????? ? ????????? ???????? ?? ?????? ???????. ??????? ??????? ? ????????????, ?????? ?????????? ??? 
????? ??????? - ??????? ?? ???????? ????????? ?????? ???????? ?????? ?????? ? ???????? ?????? ???, ????? ??????? ??? 
????? ?? ?????????? ??????? ????? ??? ?? 1.

??????? ??????

? ?????? ??????? ???? 1?n?10^6) - ?????????? ??????.

?? ?????? ??????? ???? n ????? (?10^9 ?ai ?10^9), ??????????? ????????, - ?????????? ????????? ? ??????? ??????, 
??????????????? ?? ???????????. ????? ?? ?????????? ???? ????? ??????, ?????????? ????????? ??????? ?????????.

???????? ??????

??????? ???????? ?????? ????? preorder ?????.
*/

#include <iostream>


using namespace std;

struct Node {
    int decorations;
    Node* left;
    Node* right;
};

Node* Tree(int decorations[], int left, int right) {
    if (left > right) {
        return nullptr;
    }

    int mid = (left + right) / 2;
    Node* root = new Node();
    root->decorations = decorations[mid];
    root->left = Tree(decorations, left, mid - 1);
    root->right = Tree(decorations, mid + 1, right);

    return root;
}

void preorderPrint(Node* root) {
    if (root == nullptr) {
        return;
    }

    cout << root->decorations << " ";
    preorderPrint(root->left);
    preorderPrint(root->right);
}

int main() {
    int n;
    cin >> n;

    int decorations[n];

    for (int i = 0; i < n; i++) {
        cin >> decorations[i];
    }

    Node* root = Tree(decorations, 0, n - 1);
    preorderPrint(root);

    return 0;
}

/*
???????? OOO "??????? ???? ???" ?????????? ??????????? ???????????????? ?????. ??? ?????????, ??? ?????? ?????????? ? 
??????? ?? ?????? ????? ???????? ? ??? ???????? ??? ????, ????? ???????? ???? ???????????. ? ?????????, ?????? ? ??????? 
????? ???????? ????????? ????????, ??????? ????? ?????????? ??? ?????????????. ???????????? ??????? ?? ????????, ??? 
???????????????? ????? ??? ???????? ??????? ???????? ???????? ???????, ??? ? ??????? ???????? ???????? ????????? ??????? 
????????. ???? ???????????????? ??????? ? ???????? ??????? ?????????? ???????, ?? ?????? ????????? ??? ?????????????? ? 
??????????? ? ??????? ????????? ???????:

insert x ? ???????? ?????? ???????? ? ????????? x ? ?????. ???? ? ?????? ??? ???? ??????? ? ????????? x, ?? ????????? ?????? ?? ????.

delete x ? ??????? ?? ?????? ????????? ? ????????? x. ???? ???????? ? ????????? x ? ????? ???, ?????? ?????? ?? ????.

exists x ? ???? ???? ??????? ? ????????? x ???? ? ?????, ??????? "true", ???? ??? - "false".

next x ? ??????? ??????????? ??????? ? ?????, ?????? ??????? x, ??? "none", ???? ?????? ???.

prev x ? ??????? ???????????? ??????? ? ?????, ?????? ??????? x, ??? "none", ???? ?????? ???.

? ????? ?????????? ? ??????????? ?????? ????? ?????, ?? ??????????? ?? ?????? 10^9


??????? ??????

???????? ? ??????, ?? ?????????? ?? ????????? 100.

???????? ??????

???????? ??????????????? ????????? ?????????? ???? ???????? exists, next, prev. ?????? ????? ?? ????? ???????.
*/

#include <iostream>
using namespace std;

struct Node {
    int age;
    Node* left;
    Node* right;
    int count;

    Node(int x) : age(x), count(1), left(nullptr), right(nullptr) {}
};


Node* insert(Node* root, int x) {
    if (!root) {
        return new Node(x);
    }
    if (x == root->age) {
        root->count++;
    }
    else if (x < root->age) {
        root->left = insert(root->left, x);
    }
    else if (x > root->age) {
        root->right = insert(root->right, x);
    }
    return root;
}
Node* deleteNode(Node* root, int x) {
    if (root == nullptr) {
        return root;
    }
    if (x < root->age) {
        root->left = deleteNode(root->left, x);
        return root;
        if (root->count > 1) {
            root->count--;
        }
    }
    else if (x > root->age) {
        root->right = deleteNode(root->right, x);
        return root;
        if (root->count > 1) {
            root->count--;
        }
    }
    if (root->left == NULL) {
        Node* temp = root->right;
        delete root;
        return temp;
    }
    else if (root->right == NULL) {
        Node* temp = root->left;
        delete root;
        return temp;
    }
    else {
        Node* succParent = root;
        Node* succ = root->right;

        while (succ->left != NULL) {
            succParent = succ;
            succ = succ->left;
        }
        if (succParent != root)
            succParent->left = succ->right;
        else
            succParent->right = succ->right;

        root->age = succ->age;

        delete succ;
        return root;
    }
}

bool exists(Node* root, int x) {
    if (!root) {
        return false;
    }
    if (x == root->age) {
        return true;
    }
    else if (x < root->age) {
        return exists(root->left, x);
    }
    else {
        return exists(root->right, x);
    }
}

Node* next(Node* root, int x) {
    Node* current = root;
    Node* result = nullptr;
    while (current) {
        if (current->age <= x) {
            current = current->right;
        }
        else {
            result = current;
            current = current->left;
        }
    }
    return result;
}

Node* prev(Node* root, int x) {
    Node* current = root;
    Node* result = nullptr;
    while (current) {
        if (current->age >= x) {
            current = current->left;
        }
        else {
            result = current;
            current = current->right;
        }
    }
    return result;
}

void freeTree(Node* root) {
    if (root) {
        freeTree(root->left);
        freeTree(root->right);
        delete root;
    }
}

int main() {
    Node* root = nullptr;

    string operation;
    unsigned int age;

    while (cin >> operation >> age) {
        if (operation == "insert") {
            root = insert(root, age);
        }
        else if (operation == "delete") {
            root = deleteNode(root, age);
        }
        else if (operation == "exists") {
            cout << (exists(root, age) ? "true" : "false") << endl;
        }
        else if (operation == "next") {
            Node* result = next(root, age);
            if (result) {
                cout << result->age << endl;
            }
            else {
                cout << "none" << endl;
            }
        }
        else if (operation == "prev") {
            Node* result = prev(root, age);
            if (result) {
                cout << result->age << endl;
            }
            else {
                cout << "none" << endl;
            }
        }
    }

    freeTree(root);
    return 0;
}

/*
??????? ???? ????????? ? ???????????? ??????????? ? ???? ????? ? ???????. ?? ????? ?? ??????, ?????? ? ??????? 
??????? ? ????? ???????????. ??-?? ????? ????????????? ? ????? ? ??????, ??? ??????????? ??????? ?? ?????? ??????????? 
??????? ? ????????? ?? ???? ?????????? ??? ???. ????? ???????? ??? ???????? ?? ??? ???????, ??????? ??????, ????? 
????????? ??, ??????? ??????? k-? ??? ?????? ????? ????, ??????????? ?? ??????.

??????? ??????

?? ?????? ??????? ????????? ????? n (1?n?n^5 ) - ?????????? ??????

????? ?? n ???????? ???? ??????? ???? ?????:
1k - ?????????? ????? ?????? c ????? k
0k - ??????? ?????? ???????  k-? ??? ??????
?1k - ?????? ? ????? k ?????? ? ??????

?k??10^9


???????? ??????

?? ?????? ??????? ?????? ??????? ??? k-??? ?????? ? ????? ???????

??????????

??? ?????? ? ??????? ????????? ?? ????????.

??????, ??????? ? ??????, ???????? ??? ????????
*/

#include <iostream>
using namespace std;

struct Node {
    int key;
    int weight;
    int size;
    Node* left;
    Node* right;
};

Node* getNode(int key, int weight) {
    Node* root = new Node();
    root->key = key;
    root->weight = weight;
    root->size = 1;
    root->left = nullptr;
    root->right = nullptr;
    return root;
}

Node* insert(Node* root, int key, int weight) {
    if (root == nullptr) {
        return getNode(key, weight);
    }
    if (weight < root->weight) {
        root->left = insert(root->left, key, weight);
    }
    else if (weight > root->weight) {
        root->right = insert(root->right, key, weight);
    }
    root->size++;
    return root;
}

int findKthMaximum(Node* root, int k) {
    if (root == nullptr && k <= 0 && k > root->size) {
        return -1; // ??????? ?? ??????
    }
    int rightSize = (root->right != nullptr) ? root->right->size : 0;
    if (k == rightSize + 1) {
        return root->weight;
    }
    else if (k <= rightSize) {
        return findKthMaximum(root->right, k);
    }
    else {
        return findKthMaximum(root->left, k - rightSize - 1);
    }
}

Node* findMin(Node* node) {
    while (node->left != nullptr) {
        node = node->left;
    }
    return node;
}

Node* deleteNode(Node* root, int weight) {
    if (root == nullptr) {
        return root;
    }
    if (weight < root->weight) {
        root->left = deleteNode(root->left, weight);
    }
    else if (weight > root->weight) {
        root->right = deleteNode(root->right, weight);
    }
    else {
        if (root->left == nullptr) {
            Node* temp = root->right;
            delete root;
            return temp;
        }
        else if (root->right == nullptr) {
            Node* temp = root->left;
            delete root;
            return temp;
        }
        Node* successor = findMin(root->right);
        root->weight = successor->weight;
        root->right = deleteNode(root->right, successor->weight);
    }
    if (root != nullptr) {
        root->size = 1 + (root->left != nullptr ? root->left->size : 0) + (root->right != nullptr ? root->right->size : 0);
    }
    return root;
}


int getSize(Node* root) {
    return (root != nullptr) ? root->size : 0;
}

int main() {
    Node* root = nullptr;
    int n;
    cin >> n;

    for (int i = 0; i < n; i++) {
        int command, k;
        cin >> command >> k;

        if (command == 1) {
            root = insert(root, i + 1, k);
        }
        else if (command == 0) {
            int result = findKthMaximum(root, k);
            cout << result << endl;
        }
        else if (command == -1) {
            root = deleteNode(root, k);
        }

    }

    return 0;
}

/*
?? ????? ??? ? ???? ????? ????? ? ??? ???????? ??????? ??????? ?????????? ????. ??????? ??? ?? ??? ???????????, 
?? ????????? ???? ? ?????? ?????????????? ???, ?? ?????? ??????? ???? ?????? ?????????? ???? ? ???? ????????? ??????, 
??? ? ?????? ??????? ???? ?????????? ????????? ???????? ????????? ????????? ??????. ? ?????????, ?? ???????? ?????? 
??????????? ??????, ??-?? ???? ???? ??????? ??????? ????? ????? ?????? ????????? ?? ?????? ??????.

??????? ??????

?????? ??????? n ? ?????????? ?????? ? ??????

?????? ??????? - n ?????, ???????? ?????????? ????????? ? ?????? ??????? ????? preorder ?????

???????? ??????

??????? ????? ?????? ?????????? ????????? ????? ?????? ?????? ?? ?????? ??????, ??????? ? 1
*/

#include <iostream>
#include <queue>
#include<vector>
using namespace std;

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

struct Node* createNode(int data) {
    Node* newNode = new Node();

    newNode->data = data;
    newNode->left = newNode->right = NULL;
    return newNode;
}

Node* insertNode(Node* root, int data) {

    if (root == nullptr) {
        return createNode(data);

    }

    if (data < root->data) {
        root->left = insertNode(root->left, data);
    }
    else if (data > root->data) {
        root->right = insertNode(root->right, data);
    }
    return root;
}

void printRightNodes(Node* root, vector<int>& rightNodes) {
    if (root == nullptr) {
        return;
    }
    queue<Node*> queue;
    queue.push(root);


    while (!queue.empty()) {
        int levelSize = queue.size();
        for (int i = 1; i <= levelSize; i++) {
            Node* node = queue.front();
            queue.pop();

            if (i == levelSize) {
                rightNodes.push_back(node->data);
            }

            if (node->left != nullptr) {
                queue.push(node->left);
            }
            if (node->right != nullptr) {
                queue.push(node->right);
            }
        }
    }
}

int main() {
    int n;
    cin >> n;
    if (n == 0) {
        return 0;
    }

    Node* root = nullptr;
    for (int i = 0; i < n; i++) {
        int decorations;
        cin >> decorations;
        root = insertNode(root, decorations);
    }

    vector<int> rightDecorations;
    printRightNodes(root, rightDecorations);

    for (int i = 0; i < rightDecorations.size(); i++) {
        cout << rightDecorations[i] << " ";
    }
    cout << endl;

    return 0;
}

/*
???????? ???? ????????. ????? ???????, ??? ??? ? ???????????? ? ???? ???? ???? ??????? ??????????. 
????????????? ????????? ????? ??? ???????? ?????? ?????? ? ???????? ???????? ??????? ?????? ?????? ??? ?????? ???? 
?????? ????? ??????. ????? ??????? ??? ??????? ????? ? ???????? ?? ??? ?? ????????. ???? ?????? ? ???????? ?????????, 
??????????? ???????????? ??????????? ?????. ??????? ???????, ????? ?? ???????????? ?????? ? ????? ???????? ?????? ??? 
???????. ???????? ?????, ??? ????? ? ????? ?????!

??????? ??????

? ?????? ?????? ???????? ????? n ?10^7? ?????????? ?????? ? ??????. ? ????????? 3 ??????? ???????? ?? n ????? - 
??????????  pre?, in? ? post?order ?????? ?????? ??????????????.

???????? ??????

? ???????????? ?????? ???????? YES ??? ?????????? ??????? ? NO ? ???????? ??????.
*/

#include <iostream>
#include <vector>

using namespace std;

vector<int> preorder, inorder, postorder;

bool isValid(int preStart, int preEnd, int inStart, int inEnd, int postStart, int postEnd) {
    if (preStart > preEnd) {
        return true;
    }

    int rootValue = preorder[preStart];
    int rootIndex = -1;

    for (int i = inStart; i <= inEnd; ++i) {
        if (inorder[i] == rootValue) {
            rootIndex = i;
            break;
        }
    }

    if (rootIndex == -1) {
        return false;
    }

    int leftSubtreeSize = rootIndex - inStart;
    int rightSubtreeSize = inEnd - rootIndex;

    if (!isValid(preStart + 1, preStart + leftSubtreeSize, inStart, rootIndex - 1, postStart, postStart + leftSubtreeSize - 1)) {
        return false;
    }

    if (!isValid(preStart + leftSubtreeSize + 1, preEnd, rootIndex + 1, inEnd, postStart + leftSubtreeSize, postEnd - 1)) {
        return false;
    }

    return postorder[postEnd] == rootValue;
}

int main() {
    int n;
    cin >> n;

    preorder.resize(n);
    inorder.resize(n);
    postorder.resize(n);

    for (int i = 0; i < n; ++i) {
        cin >> preorder[i];
    }

    for (int i = 0; i < n; ++i) {
        cin >> inorder[i];
    }

    for (int i = 0; i < n; ++i) {
        cin >> postorder[i];
    }

    if (isValid(0, n - 1, 0, n - 1, 0, n - 1)) {
        cout << "YES" << endl;
    }
    else {
        cout << "NO" << endl;
    }

    return 0;
}

/*
??? ????? ????????? ???????????? ??????, ?????? ?? ??? ????????? ?? n ????????? ?????. ????????? ?????? ?? ????? ?????, 
??? ?? ?????? ???????? ???????????? ?? ???????? ??????.

?? ????????? ???????, ??????????? ?? ????????? ????????????, ????????????? ????????? ???-?????? ? ?????? ????? ?? 
????????? ????????:
1. ???? ?????? ???????? ?????? ? ?????? ????????, ?? ???? ??????? ???????? 3 ?????, ????????? ??? ?????? ?? ?? 
???????? ? ?? ????? ?????????;
2. ???? ?????? ??????? ????? ? ???? ?????????, ?? ?????? ?? ??? ???????? ?? 1 ????????????? ?????;
3. ???? ?????? ??????? ????? ????? ??????????, ?? ?? ??? ????? ?? ??????????? ??????.
???????? ????????? ?????????? ?????? ? ??????? ????????.

? ?????? ???? ?????? ????? ???????, ??? ???-?????? ??????? ??????? ??????????, ???? ? ??? ????????? ????????? ????? 
??????.

??????? ??????

? ?????? ?????? ??????? ?????? ?????? ?????
n (1?n?10000) - ?????????? ????? ? ????????????.

????????? ??? ?????? ???????? ?? n ????????? ???? ? ?????? — ???????? ?????? ? ?????????, ???????????? ?????? ?? 
?????????.

???????? ??????

?????????? ??????? 3 ????? - ?????????? ?????? ? ???????, ??????? ? ???????? ???????? ??????????????.
*/

#include <iostream>
#include <string>

using namespace std;

struct Node
{
    string data;
    Node* left;
    Node* right;
    int value;

    Node(string data = string(), Node* left = nullptr, Node* right = nullptr)
        : data(data), left(left), right(right), value(3) {}
};

Node* insert(Node* root, string data)
{
    if (!root)
    {
        root = new Node(data);
        return root;
    }
    else if (root->data > data)
        root->left = insert(root->left, data);
    else if (root->data < data)
        root->right = insert(root->right, data);
    else if (root->data == data && root->value == 3)
        root->value = 1;
    else if (root->data == data && root->value == 1)
        root->value = 0;

    return root;
}

Node* search(Node* root, string data)
{
    if (!root || root->data == data)
        return root;
    if (data < root->data)
        return search(root->left, data);
    else
        return search(root->right, data);
}

int main()
{
    Node* root = nullptr;
    int n;
    cin >> n;
    auto arr = new string[3 * n];
    string s;
    string task;
    string result;
    int mark = 0;

    for (int i = 0; i < 3 * n; i++)
    {
        cin >> task;
        arr[i] = task;
        root = insert(root, task);
    }

    for (int i = 0; i < 3 * n; i++)
    {
        mark += search(root, arr[i])->value;
        if (i == n - 1 || i == 2 * n - 1 || i == 3 * n - 1)
        {
            cout << mark << " ";
            mark = 0;
        }
    }

    delete[] arr;

    return 0;
}



